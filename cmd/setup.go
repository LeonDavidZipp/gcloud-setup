package cmd

import (
	"bufio"
	"encoding/json"
	"fmt"
	"math/rand"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var setupCmd = &cobra.Command{
	Use:   "setup",
	Short: "Set up GCloud project and GitHub repository",
	Long: `Runs the complete setup process:
  1. Enable required GCP APIs
  2. Create service account with necessary roles
  3. Set up Workload Identity Federation for GitHub
  4. Create Artifact Registry repository
  5. Configure GitHub repository secrets and variables`,
	RunE: runSetup,
}

var dryRun bool
var nonInteractive bool

func init() {
	rootCmd.AddCommand(setupCmd)
	setupCmd.Flags().BoolVar(&dryRun, "dry-run", false, "Print commands without executing")
	setupCmd.Flags().BoolVarP(&nonInteractive, "yes", "y", false, "Non-interactive mode (accept all defaults)")
}

func runSetup(cmd *cobra.Command, args []string) error {
	// Check gcloud is installed and authenticated
	if err := checkGcloud(); err != nil {
		return err
	}

	// Check gh is installed and authenticated
	if err := checkGH(); err != nil {
		return err
	}

	fmt.Println()
	fmt.Println("==============================================")
	fmt.Println("  GCloud Project Setup - Interactive Mode")
	fmt.Println("==============================================")
	fmt.Println()

	// Interactive configuration with defaults
	if err := interactiveConfig(); err != nil {
		return err
	}

	// Validate all required variables are set
	if err := ValidateConfig(); err != nil {
		return err
	}

	cfg := loadConfig()

	// Show final configuration summary
	fmt.Println()
	fmt.Println("==============================================")
	fmt.Println("  Configuration Summary")
	fmt.Println("==============================================")
	fmt.Printf("  GCP Project ID:       %s\n", cfg.ProjectID)
	fmt.Printf("  GCP Project Number:   %s\n", cfg.ProjectNumber)
	fmt.Printf("  GitHub:               %s/%s\n", cfg.GitHubOrg, cfg.GitHubRepo)
	fmt.Printf("  Service Account:      %s\n", cfg.ServiceAccountName)
	fmt.Printf("  Artifact Registry:    %s (%s)\n", cfg.ArtifactRegistryName, cfg.ArtifactRegistryLocation)
	fmt.Printf("  Cloud Run Service:    %s (%s)\n", cfg.CloudRunService, cfg.CloudRunRegion)
	fmt.Println("==============================================")
	fmt.Println()

	if !nonInteractive {
		if !promptConfirm("Proceed with setup?") {
			fmt.Println("Setup cancelled.")
			return nil
		}
		fmt.Println()
	}

	steps := []struct {
		name string
		fn   func(Config) error
	}{
		{"Enabling APIs", enableAPIs},
		{"Creating Service Account", createServiceAccount},
		{"Setting up Workload Identity Federation", setupWorkloadIdentity},
		{"Creating Artifact Registry", createArtifactRegistry},
		{"Configuring GitHub Repository", configureGitHub},
	}

	for i, step := range steps {
		fmt.Printf("Step %d/%d: %s...\n", i+1, len(steps), step.name)
		fmt.Println("----------------------------------------------")
		if err := step.fn(cfg); err != nil {
			return fmt.Errorf("%s failed: %w", step.name, err)
		}
		fmt.Println()
	}

	// Save final configuration to .env.gcloud.local
	if err := saveConfig(cfg); err != nil {
		fmt.Printf("Warning: Could not save config: %v\n", err)
	}

	fmt.Println("==============================================")
	fmt.Println("  Setup Complete!")
	fmt.Println("==============================================")
	fmt.Println()
	fmt.Println("Your repository is fully configured.")
	fmt.Println("Push to main or create a PR to trigger a deployment.")
	fmt.Println()
	fmt.Println("Configuration saved to: .env.gcloud.local")

	return nil
}

type Config struct {
	ProjectID                string
	ProjectNumber            string
	GitHubOrg                string
	GitHubRepo               string
	ServiceAccountName       string
	ServiceAccountEmail      string
	ArtifactRegistryName     string
	ArtifactRegistryLocation string
	CloudRunService          string
	CloudRunRegion           string
	WorkloadIdentityProvider string
	ArtifactRegistryURL      string
}

func saveConfig(cfg Config) error {
	content := fmt.Sprintf(`# Generated by gcsetup - DO NOT COMMIT
# Generated at: %s

# GCP Project
GCP_PROJECT_ID=%s
GCP_PROJECT_NUMBER=%s

# GitHub Repository
GITHUB_ORGANIZATION=%s
GITHUB_REPOSITORY=%s

# Service Account
SERVICE_ACCOUNT_NAME=%s

# Artifact Registry
ARTIFACT_REGISTRY_NAME=%s
ARTIFACT_REGISTRY_LOCATION=%s

# Cloud Run
CLOUD_RUN_SERVICE=%s
CLOUD_RUN_REGION=%s

# Computed values (for reference)
# SERVICE_ACCOUNT_EMAIL=%s
# WORKLOAD_IDENTITY_PROVIDER=%s
# ARTIFACT_REGISTRY_URL=%s
`,
		time.Now().Format(time.RFC3339),
		cfg.ProjectID,
		cfg.ProjectNumber,
		cfg.GitHubOrg,
		cfg.GitHubRepo,
		cfg.ServiceAccountName,
		cfg.ArtifactRegistryName,
		cfg.ArtifactRegistryLocation,
		cfg.CloudRunService,
		cfg.CloudRunRegion,
		cfg.ServiceAccountEmail,
		cfg.WorkloadIdentityProvider,
		cfg.ArtifactRegistryURL,
	)

	if err := os.WriteFile(".env.gcloud.local", []byte(content), 0644); err != nil {
		return err
	}

	// Ensure it's in .gitignore
	ensureGitignore(".env.gcloud.local")

	return nil
}

func ensureGitignore(entry string) {
	data, err := os.ReadFile(".gitignore")
	if err != nil {
		// No .gitignore, create one
		os.WriteFile(".gitignore", []byte(entry+"\n"), 0644)
		return
	}

	content := string(data)
	if strings.Contains(content, entry) {
		return // Already present
	}

	// Append to .gitignore
	f, err := os.OpenFile(".gitignore", os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return
	}
	defer f.Close()

	// Check if file is empty or ends with newline
	if len(content) == 0 || content[len(content)-1] == '\n' {
		f.WriteString(entry + "\n")
	} else {
		f.WriteString("\n" + entry + "\n")
	}
}

func loadConfig() Config {
	projectID := viper.GetString("GCP_PROJECT_ID")
	projectNumber := viper.GetString("GCP_PROJECT_NUMBER")
	saName := viper.GetString("SERVICE_ACCOUNT_NAME")
	arLocation := viper.GetString("ARTIFACT_REGISTRY_LOCATION")
	arName := viper.GetString("ARTIFACT_REGISTRY_NAME")

	return Config{
		ProjectID:                projectID,
		ProjectNumber:            projectNumber,
		GitHubOrg:                viper.GetString("GITHUB_ORGANIZATION"),
		GitHubRepo:               viper.GetString("GITHUB_REPOSITORY"),
		ServiceAccountName:       saName,
		ServiceAccountEmail:      fmt.Sprintf("%s@%s.iam.gserviceaccount.com", saName, projectID),
		ArtifactRegistryName:     arName,
		ArtifactRegistryLocation: arLocation,
		CloudRunService:          viper.GetString("CLOUD_RUN_SERVICE"),
		CloudRunRegion:           viper.GetString("CLOUD_RUN_REGION"),
		WorkloadIdentityProvider: fmt.Sprintf("projects/%s/locations/global/workloadIdentityPools/github-pool/providers/github-provider", projectNumber),
		ArtifactRegistryURL:      fmt.Sprintf("%s-docker.pkg.dev/%s/%s", arLocation, projectID, arName),
	}
}

var reader = bufio.NewReader(os.Stdin)

// prompt asks user for input with a default value
func prompt(label, defaultVal string) string {
	if nonInteractive {
		if defaultVal != "" {
			fmt.Printf("  %s: %s (auto)\n", label, defaultVal)
			return defaultVal
		}
		return viper.GetString(label)
	}

	current := viper.GetString(label)
	if current != "" {
		defaultVal = current
	}

	if defaultVal != "" {
		fmt.Printf("  %s [%s]: ", label, defaultVal)
	} else {
		fmt.Printf("  %s: ", label)
	}

	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(input)

	if input == "" {
		return defaultVal
	}
	return input
}

// promptConfirm asks for y/n confirmation
func promptConfirm(label string) bool {
	fmt.Printf("%s [Y/n]: ", label)
	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(strings.ToLower(input))
	return input == "" || input == "y" || input == "yes"
}

func interactiveConfig() error {
	// Step 1: Create new project or use existing?
	fmt.Println("── GCP Project ──────────────────────────────")
	
	createNew := false
	existingID := viper.GetString("GCP_PROJECT_ID")
	
	if existingID == "" && !nonInteractive {
		fmt.Println("  1) Create a new GCP project")
		fmt.Println("  2) Use an existing project")
		fmt.Print("  Choose [1/2]: ")
		input, _ := reader.ReadString('\n')
		input = strings.TrimSpace(input)
		createNew = input == "1" || input == ""
	} else if existingID == "" && nonInteractive {
		createNew = true
	}

	var projectID, projectNumber string

	if createNew {
		// Generate a project ID suggestion from repo name
		repoName := ""
		cmd := exec.Command("git", "remote", "get-url", "origin")
		if output, err := cmd.Output(); err == nil {
			_, repoName = parseGitRemote(strings.TrimSpace(string(output)))
		}
		
		suggestedID := ""
		if repoName != "" {
			// Add random suffix for uniqueness
			suggestedID = fmt.Sprintf("%s-%d", strings.ToLower(repoName), randomSuffix())
		}

		projectID = prompt("PROJECT_ID (globally unique)", suggestedID)
		if projectID == "" {
			return fmt.Errorf("PROJECT_ID is required")
		}

		projectName := prompt("PROJECT_NAME (display name)", projectID)

		// Check for billing account
		fmt.Print("  Fetching billing accounts... ")
		billingAccounts, err := listBillingAccounts()
		if err != nil || len(billingAccounts) == 0 {
			fmt.Println("none found")
			fmt.Println("  ⚠ Warning: No billing account means most APIs won't work")
		} else {
			fmt.Printf("found %d\n", len(billingAccounts))
			for i, ba := range billingAccounts {
				fmt.Printf("    %d) %s (%s)\n", i+1, ba.displayName, ba.id)
			}
			
			var selectedBilling string
			if len(billingAccounts) == 1 {
				selectedBilling = billingAccounts[0].id
				fmt.Printf("  Using billing account: %s\n", billingAccounts[0].displayName)
			} else if !nonInteractive {
				fmt.Print("  Select billing account [1]: ")
				input, _ := reader.ReadString('\n')
				input = strings.TrimSpace(input)
				idx := 0
				if input != "" {
					fmt.Sscanf(input, "%d", &idx)
					idx--
				}
				if idx >= 0 && idx < len(billingAccounts) {
					selectedBilling = billingAccounts[idx].id
				}
			} else {
				selectedBilling = billingAccounts[0].id
			}

			// Create the project
			fmt.Printf("  Creating project %s...\n", projectID)
			if err := runCommandSilent("gcloud", "projects", "create", projectID, "--name="+projectName); err != nil {
				return fmt.Errorf("failed to create project: %w", err)
			}

			// Link billing
			if selectedBilling != "" {
				fmt.Printf("  Linking billing account...\n")
				if err := runCommandSilent("gcloud", "billing", "projects", "link", projectID, "--billing-account="+selectedBilling); err != nil {
					fmt.Println("  ⚠ Warning: Could not link billing account")
				}
			}
		}

		// Set as active project
		fmt.Printf("  Setting active project...\n")
		if err := runCommandSilent("gcloud", "config", "set", "project", projectID); err != nil {
			fmt.Println("  ⚠ Warning: Could not set active project")
		}

		// Fetch the project number
		if dryRun {
			projectNumber = "123456789012"
			fmt.Printf("  Project number: %s (dry-run mock)\n", projectNumber)
		} else {
			fmt.Print("  Fetching project number... ")
			cmd = exec.Command("gcloud", "projects", "describe", projectID, "--format=value(projectNumber)")
			output, err := cmd.Output()
			if err == nil {
				projectNumber = strings.TrimSpace(string(output))
				fmt.Printf("%s\n", projectNumber)
			} else {
				return fmt.Errorf("failed to get project number")
			}
		}
	} else {
		// Use existing project
		projectID = prompt("GCP_PROJECT_ID", existingID)
		if projectID == "" {
			return fmt.Errorf("GCP_PROJECT_ID is required")
		}

		// Auto-detect project number
		projectNumber = viper.GetString("GCP_PROJECT_NUMBER")
		if projectNumber == "" {
			if dryRun {
				projectNumber = "123456789012"
				fmt.Printf("  Project number: %s (dry-run mock)\n", projectNumber)
			} else {
				fmt.Print("  Fetching project number... ")
				cmd := exec.Command("gcloud", "projects", "describe", projectID, "--format=value(projectNumber)")
				output, err := cmd.Output()
				if err == nil {
					projectNumber = strings.TrimSpace(string(output))
					fmt.Printf("found: %s\n", projectNumber)
				} else {
					fmt.Println("failed")
					projectNumber = prompt("GCP_PROJECT_NUMBER", "")
					if projectNumber == "" {
						return fmt.Errorf("GCP_PROJECT_NUMBER is required")
					}
				}
			}
		} else {
			fmt.Printf("  GCP_PROJECT_NUMBER: %s (from config)\n", projectNumber)
		}
	}

	viper.Set("GCP_PROJECT_ID", projectID)
	viper.Set("GCP_PROJECT_NUMBER", projectNumber)

	// Step 3: GitHub org/repo (auto-detect from git remote)
	fmt.Println()
	fmt.Println("── GitHub Repository ────────────────────────")
	gitHubOrg := viper.GetString("GITHUB_ORGANIZATION")
	gitHubRepo := viper.GetString("GITHUB_REPOSITORY")

	if gitHubOrg == "" || gitHubRepo == "" {
		cmd := exec.Command("git", "remote", "get-url", "origin")
		output, err := cmd.Output()
		if err == nil {
			detectedOrg, detectedRepo := parseGitRemote(strings.TrimSpace(string(output)))
			if gitHubOrg == "" {
				gitHubOrg = detectedOrg
			}
			if gitHubRepo == "" {
				gitHubRepo = detectedRepo
			}
		}
	}

	gitHubOrg = prompt("GITHUB_ORGANIZATION", gitHubOrg)
	viper.Set("GITHUB_ORGANIZATION", gitHubOrg)

	gitHubRepo = prompt("GITHUB_REPOSITORY", gitHubRepo)
	viper.Set("GITHUB_REPOSITORY", gitHubRepo)

	// Step 4: Cloud Run configuration
	fmt.Println()
	fmt.Println("── Cloud Run ────────────────────────────────")

	// Cloud Run region (required, but default to us-central1 in dry-run/non-interactive)
	defaultRegion := viper.GetString("CLOUD_RUN_REGION")
	if defaultRegion == "" && (dryRun || nonInteractive) {
		defaultRegion = "us-central1"
	}
	cloudRunRegion := prompt("CLOUD_RUN_REGION", defaultRegion)
	if cloudRunRegion == "" {
		return fmt.Errorf("CLOUD_RUN_REGION is required (e.g., us-central1, europe-west1)")
	}
	viper.Set("CLOUD_RUN_REGION", cloudRunRegion)

	// Cloud Run service (default to repo name)
	defaultService := gitHubRepo
	cloudRunService := prompt("CLOUD_RUN_SERVICE", defaultService)
	viper.Set("CLOUD_RUN_SERVICE", cloudRunService)

	// Step 5: Service Account (default: github-actions)
	fmt.Println()
	fmt.Println("── Service Account ──────────────────────────")
	saName := prompt("SERVICE_ACCOUNT_NAME", "github-actions")
	viper.Set("SERVICE_ACCOUNT_NAME", saName)

	// Step 6: Artifact Registry (defaults based on region)
	fmt.Println()
	fmt.Println("── Artifact Registry ────────────────────────")
	arLocation := prompt("ARTIFACT_REGISTRY_LOCATION", cloudRunRegion)
	viper.Set("ARTIFACT_REGISTRY_LOCATION", arLocation)

	arName := prompt("ARTIFACT_REGISTRY_NAME", "docker")
	viper.Set("ARTIFACT_REGISTRY_NAME", arName)

	return nil
}

// parseGitRemote extracts org and repo from git remote URL
// Supports: git@github.com:org/repo.git, https://github.com/org/repo.git
func parseGitRemote(url string) (org, repo string) {
	// SSH format: git@github.com:org/repo.git
	if strings.HasPrefix(url, "git@github.com:") {
		path := strings.TrimPrefix(url, "git@github.com:")
		path = strings.TrimSuffix(path, ".git")
		parts := strings.Split(path, "/")
		if len(parts) == 2 {
			return parts[0], parts[1]
		}
	}

	// HTTPS format: https://github.com/org/repo.git
	if strings.Contains(url, "github.com/") {
		idx := strings.Index(url, "github.com/")
		path := url[idx+len("github.com/"):]
		path = strings.TrimSuffix(path, ".git")
		parts := strings.Split(path, "/")
		if len(parts) >= 2 {
			return parts[0], parts[1]
		}
	}

	return "", ""
}

type billingAccount struct {
	id          string
	displayName string
}

func listBillingAccounts() ([]billingAccount, error) {
	cmd := exec.Command("gcloud", "billing", "accounts", "list", "--format=json")
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	var accounts []struct {
		Name        string `json:"name"`
		DisplayName string `json:"displayName"`
		Open        bool   `json:"open"`
	}

	if err := json.Unmarshal(output, &accounts); err != nil {
		return nil, err
	}

	var result []billingAccount
	for _, a := range accounts {
		if a.Open {
			// Extract ID from name (billingAccounts/XXXXX-XXXXX-XXXXX)
			id := strings.TrimPrefix(a.Name, "billingAccounts/")
			result = append(result, billingAccount{id: id, displayName: a.DisplayName})
		}
	}
	return result, nil
}

func randomSuffix() int {
	rand.Seed(time.Now().UnixNano())
	return rand.Intn(9000) + 1000 // 4-digit random number
}

func checkGcloud() error {
	if _, err := exec.LookPath("gcloud"); err != nil {
		return fmt.Errorf("gcloud CLI not found. Install it: https://cloud.google.com/sdk/docs/install")
	}
	return nil
}

func checkGH() error {
	if _, err := exec.LookPath("gh"); err != nil {
		return fmt.Errorf("GitHub CLI (gh) not found. Install it: https://cli.github.com/")
	}
	// Check authentication
	cmd := exec.Command("gh", "auth", "status")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("GitHub CLI not authenticated. Run: gh auth login")
	}
	return nil
}

func runCommand(name string, args ...string) error {
	if dryRun {
		fmt.Printf("  [dry-run] %s %s\n", name, strings.Join(args, " "))
		return nil
	}
	cmd := exec.Command(name, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func runCommandSilent(name string, args ...string) error {
	if dryRun {
		fmt.Printf("  [dry-run] %s %s\n", name, strings.Join(args, " "))
		return nil
	}
	cmd := exec.Command(name, args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("%w: %s", err, strings.TrimSpace(string(output)))
	}
	return nil
}

func enableAPIs(cfg Config) error {
	apis := []string{
		"cloudresourcemanager.googleapis.com",
		"iam.googleapis.com",
		"iamcredentials.googleapis.com",
		"artifactregistry.googleapis.com",
		"run.googleapis.com",
		"secretmanager.googleapis.com",
		"cloudbuild.googleapis.com",
	}

	for _, api := range apis {
		fmt.Printf("  Enabling %s\n", api)
		if err := runCommandSilent("gcloud", "services", "enable", api, "--project="+cfg.ProjectID); err != nil {
			return err
		}
	}
	return nil
}

func createServiceAccount(cfg Config) error {
	// Create service account
	fmt.Printf("  Creating service account: %s\n", cfg.ServiceAccountName)
	err := runCommandSilent("gcloud", "iam", "service-accounts", "create", cfg.ServiceAccountName,
		"--project="+cfg.ProjectID,
		"--display-name="+cfg.ServiceAccountName+" Service Account",
		"--description=Service account for GitHub Actions CI/CD",
	)
	if err != nil {
		// Might already exist, continue
		fmt.Println("  (service account may already exist, continuing...)")
	}

	// Grant roles
	roles := []string{
		"roles/run.developer",
		"roles/artifactregistry.writer",
		"roles/secretmanager.secretAccessor",
		"roles/iam.serviceAccountUser",
		"roles/cloudbuild.builds.builder",
		"roles/logging.logWriter",
	}

	for _, role := range roles {
		fmt.Printf("  Granting %s\n", role)
		if err := runCommandSilent("gcloud", "projects", "add-iam-policy-binding", cfg.ProjectID,
			"--member=serviceAccount:"+cfg.ServiceAccountEmail,
			"--role="+role,
			"--condition=None",
		); err != nil {
			return err
		}
	}

	return nil
}

func setupWorkloadIdentity(cfg Config) error {
	// Create Workload Identity Pool
	fmt.Println("  Creating Workload Identity Pool...")
	err := runCommandSilent("gcloud", "iam", "workload-identity-pools", "create", "github-pool",
		"--project="+cfg.ProjectID,
		"--location=global",
		"--display-name=GitHub Actions Pool",
	)
	if err != nil {
		fmt.Println("  (pool may already exist, continuing...)")
	}

	// Create Provider
	fmt.Println("  Creating OIDC Provider...")
	err = runCommandSilent("gcloud", "iam", "workload-identity-pools", "providers", "create-oidc", "github-provider",
		"--project="+cfg.ProjectID,
		"--location=global",
		"--workload-identity-pool=github-pool",
		"--display-name=GitHub Provider",
		"--attribute-mapping=google.subject=assertion.sub,attribute.actor=assertion.actor,attribute.repository=assertion.repository",
		"--issuer-uri=https://token.actions.githubusercontent.com",
	)
	if err != nil {
		fmt.Println("  (provider may already exist, continuing...)")
	}

	// Allow repo to impersonate service account
	fmt.Println("  Configuring repository access...")
	member := fmt.Sprintf("principalSet://iam.googleapis.com/projects/%s/locations/global/workloadIdentityPools/github-pool/attribute.repository/%s/%s",
		cfg.ProjectNumber, cfg.GitHubOrg, cfg.GitHubRepo)

	return runCommandSilent("gcloud", "iam", "service-accounts", "add-iam-policy-binding", cfg.ServiceAccountEmail,
		"--project="+cfg.ProjectID,
		"--role=roles/iam.workloadIdentityUser",
		"--member="+member,
	)
}

func createArtifactRegistry(cfg Config) error {
	fmt.Printf("  Creating repository: %s\n", cfg.ArtifactRegistryName)
	err := runCommandSilent("gcloud", "artifacts", "repositories", "create", cfg.ArtifactRegistryName,
		"--project="+cfg.ProjectID,
		"--location="+cfg.ArtifactRegistryLocation,
		"--repository-format=docker",
		"--description=Container registry for CI/CD",
	)
	if err != nil {
		fmt.Println("  (repository may already exist, continuing...)")
	}
	return nil
}

func configureGitHub(cfg Config) error {
	repo := fmt.Sprintf("%s/%s", cfg.GitHubOrg, cfg.GitHubRepo)

	// Set secrets
	fmt.Println("  Setting secrets...")
	secrets := map[string]string{
		"GCP_SERVICE_ACCOUNT":            cfg.ServiceAccountEmail,
		"GCP_WORKLOAD_IDENTITY_PROVIDER": cfg.WorkloadIdentityProvider,
	}

	for name, value := range secrets {
		fmt.Printf("    %s\n", name)
		if dryRun {
			fmt.Printf("    [dry-run] gh secret set %s --repo %s\n", name, repo)
			continue
		}
		cmd := exec.Command("gh", "secret", "set", name, "--repo", repo, "--body", value)
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to set secret %s: %w", name, err)
		}
	}

	// Set variables
	fmt.Println("  Setting variables...")
	variables := map[string]string{
		"CLOUD_RUN_SERVICE":     cfg.CloudRunService,
		"CLOUD_RUN_REGION":      cfg.CloudRunRegion,
		"ARTIFACT_REGISTRY_URL": cfg.ArtifactRegistryURL,
	}

	for name, value := range variables {
		fmt.Printf("    %s\n", name)
		if dryRun {
			fmt.Printf("    [dry-run] gh variable set %s --repo %s\n", name, repo)
			continue
		}
		cmd := exec.Command("gh", "variable", "set", name, "--repo", repo, "--body", value)
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to set variable %s: %w", name, err)
		}
	}

	return nil
}
