package cmd

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var serviceCmd = &cobra.Command{
	Use:   "service",
	Short: "Configure service deployment in an existing GCP project",
	Long: `Configure a service for deployment in an existing GCP project:
  1. Set up Workload Identity Federation for GitHub
  2. Configure GitHub repository secrets and variables
  3. Create deployment environments`,
	RunE: runService,
}

var dryRun bool
var nonInteractive bool

func init() {
	rootCmd.AddCommand(serviceCmd)
	serviceCmd.Flags().BoolVar(&dryRun, "dry-run", false, "Print commands without executing")
	serviceCmd.Flags().BoolVarP(&nonInteractive, "yes", "y", false, "Non-interactive mode (accept all defaults)")
}

func runService(cmd *cobra.Command, args []string) error {
	if err := checkGcloud(); err != nil {
		return err
	}

	if err := checkGH(); err != nil {
		return err
	}

	fmt.Println()
	fmt.Println("==============================================")
	fmt.Println("  Service Setup - Interactive Mode")
	fmt.Println("==============================================")
	fmt.Println()

	if err := interactiveConfig(); err != nil {
		return err
	}

	if err := ValidateConfig(); err != nil {
		return err
	}

	cfg := loadConfig()

	fmt.Println()
	fmt.Println("==============================================")
	fmt.Println("  Configuration Summary")
	fmt.Println("==============================================")
	fmt.Printf("  GCP Project ID:       %s\n", cfg.ProjectID)
	fmt.Printf("  GCP Project Number:   %s\n", cfg.ProjectNumber)
	fmt.Printf("  GitHub:               %s/%s\n", cfg.GitHubOrg, cfg.GitHubRepo)
	fmt.Printf("  Service Account:      %s\n", cfg.ServiceAccountName)
	fmt.Printf("  Artifact Registry:    %s (%s)\n", cfg.ArtifactRegistryName, cfg.ArtifactRegistryLocation)
	fmt.Printf("  Cloud Run Service:    %s (%s)\n", cfg.CloudRunService, cfg.CloudRunRegion)
	fmt.Println("==============================================")
	fmt.Println()

	if !nonInteractive {
		if !promptConfirm("Proceed with setup?") {
			fmt.Println("Setup cancelled.")
			return nil
		}
		fmt.Println()
	}

	steps := []struct {
		name string
		fn   func(Config) error
	}{
		{"Setting up Workload Identity Federation", setupWorkloadIdentity},
		{"Configuring GitHub Repository", configureGitHub},
	}

	for i, step := range steps {
		fmt.Printf("Step %d/%d: %s...\n", i+1, len(steps), step.name)
		fmt.Println("----------------------------------------------")
		if err := step.fn(cfg); err != nil {
			return fmt.Errorf("%s failed: %w", step.name, err)
		}
		fmt.Println()
	}

	if err := saveConfig(cfg); err != nil {
		fmt.Printf("Warning: Could not save config: %v\n", err)
	}

	fmt.Println("==============================================")
	fmt.Println("  Service Setup Complete!")
	fmt.Println("==============================================")
	fmt.Println()
	fmt.Println("Your service is configured for deployment.")
	fmt.Println("Push to main or create a PR to trigger a deployment.")
	fmt.Println()
	fmt.Println("Configuration saved to: .env.gcloud.local")

	return nil
}

type Config struct {
	ProjectID                string
	ProjectNumber            string
	GitHubOrg                string
	GitHubRepo               string
	ServiceAccountName       string
	ServiceAccountEmail      string
	ArtifactRegistryName     string
	ArtifactRegistryLocation string
	CloudRunService          string
	CloudRunRegion           string
	WorkloadIdentityProvider string
	ArtifactRegistryURL      string
}

func saveConfig(cfg Config) error {
	content := fmt.Sprintf(`# Generated by gcsetup - DO NOT COMMIT
# Generated at: %s

# GCP Project
GCP_PROJECT_ID=%s
GCP_PROJECT_NUMBER=%s

# GitHub Repository
GITHUB_ORGANIZATION=%s
GITHUB_REPOSITORY=%s

# Service Account
SERVICE_ACCOUNT_NAME=%s

# Artifact Registry
ARTIFACT_REGISTRY_NAME=%s
ARTIFACT_REGISTRY_LOCATION=%s

# Cloud Run
CLOUD_RUN_SERVICE=%s
CLOUD_RUN_REGION=%s

# Computed values (for reference)
# SERVICE_ACCOUNT_EMAIL=%s
# WORKLOAD_IDENTITY_PROVIDER=%s
# ARTIFACT_REGISTRY_URL=%s
`,
		time.Now().Format(time.RFC3339),
		cfg.ProjectID,
		cfg.ProjectNumber,
		cfg.GitHubOrg,
		cfg.GitHubRepo,
		cfg.ServiceAccountName,
		cfg.ArtifactRegistryName,
		cfg.ArtifactRegistryLocation,
		cfg.CloudRunService,
		cfg.CloudRunRegion,
		cfg.ServiceAccountEmail,
		cfg.WorkloadIdentityProvider,
		cfg.ArtifactRegistryURL,
	)

	if err := os.WriteFile(".env.gcloud.local", []byte(content), 0644); err != nil {
		return err
	}

	ensureGitignore(".env.gcloud.local")

	return nil
}

func ensureGitignore(entry string) {
	data, err := os.ReadFile(".gitignore")
	if err != nil {
		_ = os.WriteFile(".gitignore", []byte(entry+"\n"), 0644)
		return
	}

	content := string(data)
	if strings.Contains(content, entry) {
		return
	}

	f, err := os.OpenFile(".gitignore", os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return
	}
	defer func() { _ = f.Close() }()

	if len(content) == 0 || content[len(content)-1] == '\n' {
		_, _ = f.WriteString(entry + "\n")
	} else {
		_, _ = f.WriteString("\n" + entry + "\n")
	}
}

func loadConfig() Config {
	projectID := viper.GetString("GCP_PROJECT_ID")
	projectNumber := viper.GetString("GCP_PROJECT_NUMBER")
	saName := viper.GetString("SERVICE_ACCOUNT_NAME")
	arLocation := viper.GetString("ARTIFACT_REGISTRY_LOCATION")
	arName := viper.GetString("ARTIFACT_REGISTRY_NAME")

	return Config{
		ProjectID:                projectID,
		ProjectNumber:            projectNumber,
		GitHubOrg:                viper.GetString("GITHUB_ORGANIZATION"),
		GitHubRepo:               viper.GetString("GITHUB_REPOSITORY"),
		ServiceAccountName:       saName,
		ServiceAccountEmail:      fmt.Sprintf("%s@%s.iam.gserviceaccount.com", saName, projectID),
		ArtifactRegistryName:     arName,
		ArtifactRegistryLocation: arLocation,
		CloudRunService:          viper.GetString("CLOUD_RUN_SERVICE"),
		CloudRunRegion:           viper.GetString("CLOUD_RUN_REGION"),
		WorkloadIdentityProvider: fmt.Sprintf(
			"projects/%s/locations/global/workloadIdentityPools/github-pool/providers/github-provider",
			projectNumber,
		),
		ArtifactRegistryURL: fmt.Sprintf("%s-docker.pkg.dev/%s/%s", arLocation, projectID, arName),
	}
}

var reader = bufio.NewReader(os.Stdin)

func prompt(label, defaultVal string) string {
	if nonInteractive {
		if defaultVal != "" {
			fmt.Printf("  %s: %s (auto)\n", label, defaultVal)
			return defaultVal
		}
		return viper.GetString(label)
	}

	current := viper.GetString(label)
	if current != "" {
		defaultVal = current
	}

	if defaultVal != "" {
		fmt.Printf("  %s [%s]: ", label, defaultVal)
	} else {
		fmt.Printf("  %s: ", label)
	}

	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(input)

	if input == "" {
		return defaultVal
	}
	return input
}

func promptConfirm(label string) bool {
	fmt.Printf("%s [Y/n]: ", label)
	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(strings.ToLower(input))
	return input == "" || input == "y" || input == "yes"
}

func interactiveConfig() error {
	fmt.Println("â”€â”€ GCP Project â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

	createNew := false
	existingID := viper.GetString("GCP_PROJECT_ID")

	if existingID == "" && !nonInteractive {
		fmt.Println("  1) Create a new GCP project")
		fmt.Println("  2) Use an existing project")
		fmt.Print("  Choose [1/2]: ")
		input, _ := reader.ReadString('\n')
		input = strings.TrimSpace(input)
		createNew = input == "1" || input == ""
	} else if existingID == "" && nonInteractive {
		createNew = true
	}

	var projectID, projectNumber string

	if createNew {

		repoName := ""
		cmd := exec.Command("git", "remote", "get-url", "origin")
		if output, err := cmd.Output(); err == nil {
			_, repoName = parseGitRemote(strings.TrimSpace(string(output)))
		}

		suggestedID := ""
		if repoName != "" {
			suggestedID = fmt.Sprintf("%s-%s", strings.ToLower(repoName), randomSuffix())
		}

		projectID = prompt("PROJECT_ID (globally unique)", suggestedID)
		if projectID == "" {
			return fmt.Errorf("PROJECT_ID is required")
		}

		projectName := prompt("PROJECT_NAME (display name)", projectID)

		fmt.Print("  Fetching billing accounts... ")
		billingAccounts, err := listBillingAccounts()
		if err != nil || len(billingAccounts) == 0 {
			fmt.Println("none found")
			fmt.Println("  âš  Warning: No billing account means most APIs won't work")
		} else {
			fmt.Printf("found %d\n", len(billingAccounts))
			for i, ba := range billingAccounts {
				fmt.Printf("    %d) %s (%s)\n", i+1, ba.displayName, ba.id)
			}

			var selectedBilling string
			if len(billingAccounts) == 1 {
				selectedBilling = billingAccounts[0].id
				fmt.Printf("  Using billing account: %s\n", billingAccounts[0].displayName)
			} else if !nonInteractive {
				fmt.Print("  Select billing account [1]: ")
				input, _ := reader.ReadString('\n')
				input = strings.TrimSpace(input)
				idx := 0
				if input != "" {
					_, _ = fmt.Sscanf(input, "%d", &idx)
					idx--
				}
				if idx >= 0 && idx < len(billingAccounts) {
					selectedBilling = billingAccounts[idx].id
				}
			} else {
				selectedBilling = billingAccounts[0].id
			}

			fmt.Printf("  Creating project %s...\n", projectID)
			err := runCommandSilent("projects", "create", projectID, "--name="+projectName)
			if err != nil {
				return fmt.Errorf("failed to create project: %w", err)
			}

			if selectedBilling != "" {
				fmt.Printf("  Linking billing account...\n")
				err := runCommandSilent(
					"billing", "projects", "link", projectID,
					"--billing-account="+selectedBilling,
				)
				if err != nil {
					fmt.Println("  âš  Warning: Could not link billing account")
				}
			}
		}

		fmt.Printf("  Setting active project...\n")
		if err := runCommandSilent("config", "set", "project", projectID); err != nil {
			fmt.Println("  âš  Warning: Could not set active project")
		}

		if dryRun {
			projectNumber = "123456789012"
			fmt.Printf("  Project number: %s (dry-run mock)\n", projectNumber)
		} else {
			fmt.Print("  Fetching project number... ")
			cmd = exec.Command("gcloud", "projects", "describe", projectID, "--format=value(projectNumber)")
			output, err := cmd.Output()
			if err == nil {
				projectNumber = strings.TrimSpace(string(output))
				fmt.Printf("%s\n", projectNumber)
			} else {
				return fmt.Errorf("failed to get project number")
			}
		}
	} else {

		projectID = prompt("GCP_PROJECT_ID", existingID)
		if projectID == "" {
			return fmt.Errorf("GCP_PROJECT_ID is required")
		}

		projectNumber = viper.GetString("GCP_PROJECT_NUMBER")
		if projectNumber == "" {
			if dryRun {
				projectNumber = "123456789012"
				fmt.Printf("  Project number: %s (dry-run mock)\n", projectNumber)
			} else {
				fmt.Print("  Fetching project number... ")
				cmd := exec.Command("gcloud", "projects", "describe", projectID, "--format=value(projectNumber)")
				output, err := cmd.Output()
				if err == nil {
					projectNumber = strings.TrimSpace(string(output))
					fmt.Printf("found: %s\n", projectNumber)
				} else {
					fmt.Println("failed")
					projectNumber = prompt("GCP_PROJECT_NUMBER", "")
					if projectNumber == "" {
						return fmt.Errorf("GCP_PROJECT_NUMBER is required")
					}
				}
			}
		} else {
			fmt.Printf("  GCP_PROJECT_NUMBER: %s (from config)\n", projectNumber)
		}
	}

	viper.Set("GCP_PROJECT_ID", projectID)
	viper.Set("GCP_PROJECT_NUMBER", projectNumber)

	fmt.Println()
	fmt.Println("â”€â”€ GitHub Repository â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
	gitHubOrg := viper.GetString("GITHUB_ORGANIZATION")
	gitHubRepo := viper.GetString("GITHUB_REPOSITORY")

	if gitHubOrg == "" || gitHubRepo == "" {
		cmd := exec.Command("git", "remote", "get-url", "origin")
		output, err := cmd.Output()
		if err == nil {
			detectedOrg, detectedRepo := parseGitRemote(strings.TrimSpace(string(output)))
			if gitHubOrg == "" {
				gitHubOrg = detectedOrg
			}
			if gitHubRepo == "" {
				gitHubRepo = detectedRepo
			}
		}
	}

	gitHubOrg = prompt("GITHUB_ORGANIZATION", gitHubOrg)
	viper.Set("GITHUB_ORGANIZATION", gitHubOrg)

	gitHubRepo = prompt("GITHUB_REPOSITORY", gitHubRepo)
	viper.Set("GITHUB_REPOSITORY", gitHubRepo)

	fmt.Println()
	fmt.Println("â”€â”€ Cloud Run â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

	defaultRegion := viper.GetString("CLOUD_RUN_REGION")
	if defaultRegion == "" && (dryRun || nonInteractive) {
		defaultRegion = "us-central1"
	}
	cloudRunRegion := prompt("CLOUD_RUN_REGION", defaultRegion)
	if cloudRunRegion == "" {
		return fmt.Errorf("CLOUD_RUN_REGION is required (e.g., us-central1, europe-west1)")
	}
	viper.Set("CLOUD_RUN_REGION", cloudRunRegion)

	defaultService := gitHubRepo
	cloudRunService := prompt("CLOUD_RUN_SERVICE", defaultService)
	viper.Set("CLOUD_RUN_SERVICE", cloudRunService)

	fmt.Println()
	fmt.Println("â”€â”€ Service Account â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
	saName := prompt("SERVICE_ACCOUNT_NAME", "github-actions")
	viper.Set("SERVICE_ACCOUNT_NAME", saName)

	fmt.Println()
	fmt.Println("â”€â”€ Artifact Registry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
	arLocation := prompt("ARTIFACT_REGISTRY_LOCATION", cloudRunRegion)
	viper.Set("ARTIFACT_REGISTRY_LOCATION", arLocation)

	arName := prompt("ARTIFACT_REGISTRY_NAME", "docker")
	viper.Set("ARTIFACT_REGISTRY_NAME", arName)

	return nil
}

func parseGitRemote(url string) (org, repo string) {

	if strings.HasPrefix(url, "git@github.com:") {
		path := strings.TrimPrefix(url, "git@github.com:")
		path = strings.TrimSuffix(path, ".git")
		parts := strings.Split(path, "/")
		if len(parts) == 2 {
			return parts[0], parts[1]
		}
	}

	if strings.Contains(url, "github.com/") {
		idx := strings.Index(url, "github.com/")
		path := url[idx+len("github.com/"):]
		path = strings.TrimSuffix(path, ".git")
		parts := strings.Split(path, "/")
		if len(parts) >= 2 {
			return parts[0], parts[1]
		}
	}

	return "", ""
}

type billingAccount struct {
	id          string
	displayName string
}

func listBillingAccounts() ([]billingAccount, error) {
	cmd := exec.Command("gcloud", "billing", "accounts", "list", "--format=json")
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	var accounts []struct {
		Name        string `json:"name"`
		DisplayName string `json:"displayName"`
		Open        bool   `json:"open"`
	}

	if err := json.Unmarshal(output, &accounts); err != nil {
		return nil, err
	}

	var result []billingAccount
	for _, a := range accounts {
		if a.Open {

			id := strings.TrimPrefix(a.Name, "billingAccounts/")
			result = append(result, billingAccount{id: id, displayName: a.DisplayName})
		}
	}
	return result, nil
}

func checkGcloud() error {
	if _, err := exec.LookPath("gcloud"); err != nil {
		return fmt.Errorf("gcloud CLI not found. Please install the Google Cloud SDK")
	}
	return nil
}

func checkGH() error {
	if _, err := exec.LookPath("gh"); err != nil {
		return fmt.Errorf("GitHub CLI (gh) not found. Please install it: https://cli.github.com")
	}
	cmd := exec.Command("gh", "auth", "status")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("GitHub CLI not authenticated. Run: gh auth login")
	}
	return nil
}

func runCommandSilent(args ...string) error {
	if dryRun {
		fmt.Printf("  [dry-run] gcloud %s\n", strings.Join(args, " "))
		return nil
	}
	cmd := exec.Command("gcloud", args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("%w: %s", err, strings.TrimSpace(string(output)))
	}
	return nil
}

func setupWorkloadIdentity(cfg Config) error {
	fmt.Println("  Checking Workload Identity Pool status...")
	poolState := getPoolState(cfg.ProjectID, "github-pool")

	switch poolState {
	case "DELETED":
		fmt.Println("  Pool is soft-deleted, restoring...")
		if err := runCommandSilent("iam", "workload-identity-pools", "undelete", "github-pool",
			"--project="+cfg.ProjectID,
			"--location=global",
		); err != nil {
			return fmt.Errorf("failed to restore workload identity pool: %w", err)
		}
		fmt.Println("  Pool restored successfully")
	case "ACTIVE":
		fmt.Println("  Pool already exists and is active")
	case "NOT_FOUND":
		fmt.Println("  Creating new pool...")
		if err := runCommandSilent("iam", "workload-identity-pools", "create", "github-pool",
			"--project="+cfg.ProjectID,
			"--location=global",
			"--display-name=GitHub Actions Pool",
		); err != nil {
			return fmt.Errorf("failed to create workload identity pool: %w", err)
		}
		fmt.Println("  Pool created successfully")
	}

	fmt.Println("  Waiting for pool to be ready...")
	time.Sleep(5 * time.Second)

	fmt.Println("  Checking OIDC Provider status...")
	providerState := getProviderState(cfg.ProjectID, "github-pool", "github-provider")

	switch providerState {
	case "DELETED":
		fmt.Println("  Provider is soft-deleted, restoring...")
		if err := runCommandSilent("iam", "workload-identity-pools", "providers", "undelete", "github-provider",
			"--project="+cfg.ProjectID,
			"--location=global",
			"--workload-identity-pool=github-pool",
		); err != nil {
			return fmt.Errorf("failed to restore OIDC provider: %w", err)
		}
		fmt.Println("  Provider restored successfully")
	case "ACTIVE":
		fmt.Println("  Provider already exists and is active")
	case "NOT_FOUND":
		fmt.Println("  Creating new provider...")
		attrMapping := "google.subject=assertion.sub," +
			"attribute.actor=assertion.actor," +
			"attribute.repository=assertion.repository," +
			"attribute.repository_owner=assertion.repository_owner"
		attrCondition := fmt.Sprintf("assertion.repository_owner == '%s'", cfg.GitHubOrg)

		if err := runCommandSilent("iam", "workload-identity-pools", "providers", "create-oidc", "github-provider",
			"--project="+cfg.ProjectID,
			"--location=global",
			"--workload-identity-pool=github-pool",
			"--display-name=GitHub Provider",
			"--issuer-uri=https://token.actions.githubusercontent.com",
			"--attribute-mapping="+attrMapping,
			"--attribute-condition="+attrCondition,
		); err != nil {
			return fmt.Errorf("failed to create OIDC provider: %w", err)
		}
		fmt.Println("  Provider created successfully")
	}

	fmt.Println("  Configuring repository access...")
	memberFmt := "principalSet://iam.googleapis.com/projects/%s/locations/global/" +
		"workloadIdentityPools/github-pool/attribute.repository/%s/%s"
	member := fmt.Sprintf(memberFmt, cfg.ProjectNumber, cfg.GitHubOrg, cfg.GitHubRepo)

	return runCommandSilent("iam", "service-accounts", "add-iam-policy-binding", cfg.ServiceAccountEmail,
		"--project="+cfg.ProjectID,
		"--role=roles/iam.workloadIdentityUser",
		"--member="+member,
	)
}

func getPoolState(projectID, poolID string) string {
	if dryRun {
		return "NOT_FOUND"
	}
	cmd := exec.Command("gcloud", "iam", "workload-identity-pools", "describe", poolID,
		"--project="+projectID,
		"--location=global",
		"--format=value(state)",
	)
	output, err := cmd.Output()
	if err != nil {
		return "NOT_FOUND"
	}
	state := strings.TrimSpace(string(output))
	if state == "DELETED" {
		return "DELETED"
	}
	return "ACTIVE"
}

func getProviderState(projectID, poolID, providerID string) string {
	if dryRun {
		return "NOT_FOUND"
	}
	cmd := exec.Command("gcloud", "iam", "workload-identity-pools", "providers", "describe", providerID,
		"--project="+projectID,
		"--location=global",
		"--workload-identity-pool="+poolID,
		"--format=value(state)",
	)
	output, err := cmd.Output()
	if err != nil {
		return "NOT_FOUND"
	}
	state := strings.TrimSpace(string(output))
	if state == "DELETED" {
		return "DELETED"
	}
	return "ACTIVE"
}

func configureGitHub(cfg Config) error {
	repo := fmt.Sprintf("%s/%s", cfg.GitHubOrg, cfg.GitHubRepo)

	fmt.Println("  Setting secrets...")
	secrets := map[string]string{
		"GCP_SERVICE_ACCOUNT":            cfg.ServiceAccountEmail,
		"GCP_WORKLOAD_IDENTITY_PROVIDER": cfg.WorkloadIdentityProvider,
	}

	for name, value := range secrets {
		if dryRun {
			fmt.Printf("    [dry-run] gh secret set %s --repo %s\n", name, repo)
			continue
		}

		cmd := exec.Command("gh", "secret", "list", "--repo", repo)
		output, _ := cmd.Output()
		if strings.Contains(string(output), name) {
			fmt.Printf("    %s (already set, skipping)\n", name)
			continue
		}
		fmt.Printf("    %s\n", name)
		cmd = exec.Command("gh", "secret", "set", name, "--repo", repo, "--body", value)
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to set secret %s: %w", name, err)
		}
	}

	fmt.Println("  Setting variables...")
	variables := map[string]string{
		"CLOUD_RUN_SERVICE":     cfg.CloudRunService,
		"CLOUD_RUN_REGION":      cfg.CloudRunRegion,
		"ARTIFACT_REGISTRY_URL": cfg.ArtifactRegistryURL,
	}

	for name, value := range variables {
		if dryRun {
			fmt.Printf("    [dry-run] gh variable set %s --repo %s\n", name, repo)
			continue
		}

		cmd := exec.Command("gh", "variable", "list", "--repo", repo)
		output, _ := cmd.Output()
		if strings.Contains(string(output), name) {
			fmt.Printf("    %s (already set, skipping)\n", name)
			continue
		}
		fmt.Printf("    %s\n", name)
		cmd = exec.Command("gh", "variable", "set", name, "--repo", repo, "--body", value)
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to set variable %s: %w", name, err)
		}
	}

	fmt.Println("  Creating environments...")
	environments := []string{"development", "staging", "production", "preview"}

	for _, env := range environments {
		fmt.Printf("    %s\n", env)
		if dryRun {
			fmt.Printf("    [dry-run] gh api repos/%s/environments/%s -X PUT\n", repo, env)
			continue
		}
		cmd := exec.Command("gh", "api", fmt.Sprintf("repos/%s/environments/%s", repo, env), "-X", "PUT")
		if err := cmd.Run(); err != nil {
			fmt.Printf("    âš  Could not create environment %s (may require admin access)\n", env)
		}
	}

	fmt.Println()
	fmt.Println("  ðŸ’¡ Tip: Add protection rules in GitHub â†’ Settings â†’ Environments")
	fmt.Println("     For 'production': require reviewers before deployment")

	return nil
}
